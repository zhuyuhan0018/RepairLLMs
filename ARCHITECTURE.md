# System Architecture

## 系统架构说明

本系统实现了基于逆向工程思维链（Reverse-Engineered Reasoning, REER）的代码修复系统。

## 核心组件

### 1. 模型层 (`models/`)

#### `aliyun_model.py`
- **功能**: 阿里云大模型API封装
- **用途**: 用于初始思维链构造
- **特点**: 
  - 支持流式和非流式生成
  - 自动处理API响应格式差异
  - 错误处理和重试机制

#### `local_model.py`
- **功能**: 本地Qwen2模型封装
- **用途**: 
  - 困惑度计算
  - 思维链优化
- **特点**:
  - 自动设备选择（CUDA/CPU）
  - 支持困惑度分段计算
  - 内存优化

### 2. 核心处理层 (`core/`)

#### `initial_chain_builder.py`
- **功能**: 初始思维链构造
- **主要方法**:
  - `analyze_repair_order()`: 分析修复顺序
  - `build_fix_point_chain()`: 构建单个修复点的思维链
  - `merge_thinking_chains()`: 合并多个思维链
- **工作流程**:
  1. 分析修复步骤顺序
  2. 对每个修复点迭代生成思维链
  3. 支持grep命令请求
  4. 验证修复正确性
  5. 根据反馈迭代改进

#### `perplexity_optimizer.py`
- **功能**: 基于困惑度的思维链优化
- **主要方法**:
  - `segment_thinking_chain()`: 分段思维链
  - `analyze_perplexity()`: 分析困惑度
  - `optimize_thinking_chain()`: 优化高困惑度片段
  - `preserve_critical_parts()`: 保留关键部分
- **优化策略**:
  - 识别高困惑度片段（阈值可配置）
  - 使用阿里云模型生成优化版本
  - 保留关键代码修复部分

#### `repair_pipeline.py`
- **功能**: 主流程控制
- **职责**:
  - 协调各个组件
  - 管理整个修复流程
  - 保存输出结果
  - 批量处理支持

### 3. 工具层 (`utils/`)

#### `grep_tool.py`
- **功能**: Grep命令工具集成
- **特性**:
  - 安全执行grep命令
  - 超时保护（10秒）
  - 命令提取和验证
  - 错误处理

#### `prompts.py`
- **功能**: 提示词模板管理
- **包含的提示词**:
  - 修复顺序分析提示
  - 初始修复生成提示
  - 修复验证提示
  - 迭代反思提示
  - 思维链合并提示
  - 困惑度优化提示

### 4. 数据层

#### `data_loader.py`
- **功能**: 数据加载
- **支持格式**:
  - JSON文件
  - SQLite数据库
  - 单个字典对象

## 工作流程

```
输入: 漏洞代码 + 修复代码 + 漏洞位置
  │
  ├─> [1] 修复顺序分析 (Aliyun模型)
  │     └─> 识别修复点及其顺序
  │
  ├─> [2] 逐点修复处理 (Aliyun模型)
  │     ├─> 生成初始分析和修复
  │     ├─> [可选] 请求grep命令
  │     ├─> 执行grep并返回结果
  │     ├─> 验证修复正确性
  │     ├─> 根据反馈迭代改进
  │     └─> 生成修复点思维链
  │
  ├─> [3] 合并思维链 (Aliyun模型)
  │     └─> 生成完整思维链
  │
  ├─> [4] 困惑度分析 (本地模型)
  │     └─> 识别高困惑度片段
  │
  ├─> [5] 优化思维链 (Aliyun模型)
  │     ├─> 替换高困惑度片段
  │     └─> 保留关键修复部分
  │
  └─> 输出: 优化后的思维链
```

## 数据流

### 输入数据格式
```python
{
    'buggy_code': str,      # 漏洞代码
    'fixed_code': str,       # 修复代码
    'bug_location': str,     # 漏洞位置
    'case_id': str           # 案例ID（可选）
}
```

### 输出数据格式
```python
{
    'case_id': str,
    'bug_location': str,
    'fix_points': List[Dict],
    'initial_chain': str,           # 初始思维链
    'optimized_chain': str,          # 优化后思维链
    'individual_chains': Dict       # 各修复点的思维链
}
```

## 关键设计决策

### 1. 分离初始构造和优化
- **原因**: 初始构造需要强大的模型（阿里云），优化可以使用本地模型
- **好处**: 平衡成本和性能

### 2. 迭代式修复生成
- **原因**: 复杂修复需要多轮思考
- **实现**: 通过验证反馈循环实现

### 3. Grep工具集成
- **原因**: 代码修复需要上下文信息
- **实现**: 模型可以请求grep命令，系统安全执行

### 4. 困惑度引导优化
- **原因**: 提高思维链的自然性和连贯性
- **实现**: 分段分析，替换高困惑度片段

### 5. 关键部分保护
- **原因**: 确保代码修复的正确性不被破坏
- **实现**: 优化后替换回原始代码块

## 配置参数

### 生成参数
- `MAX_ITERATIONS`: 每个修复点的最大迭代次数（默认10）
- `MAX_GREP_ATTEMPTS`: 每次迭代的最大grep尝试次数（默认3）
- `TEMPERATURE`: 生成温度（默认0.7）
- `MAX_TOKENS`: 最大生成token数（默认2048）

### 优化参数
- `PERPLEXITY_THRESHOLD`: 困惑度阈值（默认3.0）
- `MIN_REPLACEMENT_LENGTH`: 最小替换长度（默认50字符）

## 扩展点

### 1. 添加新的数据源
在 `data_loader.py` 中添加新的加载方法

### 2. 自定义提示词
在 `utils/prompts.py` 中添加新的提示词模板

### 3. 添加新的工具
在 `utils/` 中创建新工具模块，并在 `initial_chain_builder.py` 中集成

### 4. 自定义优化策略
在 `perplexity_optimizer.py` 中修改优化逻辑

## 性能考虑

1. **本地模型加载**: 首次加载较慢，后续可复用
2. **API调用**: 使用批处理减少API调用次数
3. **困惑度计算**: 分段计算避免内存溢出
4. **Grep执行**: 超时保护避免阻塞

## 安全考虑

1. **Grep命令**: 严格验证，防止命令注入
2. **API密钥**: 存储在配置文件中，不应提交到版本控制
3. **文件访问**: 限制在指定代码库路径内

